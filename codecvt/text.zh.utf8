有关UTF或编码格式的一般问题
问：Unicode是16位编码吗？

答：不能。从1991年到1995年，Unicode的第一个版本是16位编码，但是从Unicode 2.0（1996年7月）开始，它并不是16位编码。Unicode标准对U + 0000..U + 10FFFF范围内的字符进行编码，这相当于21位代码空间。根据您选择的编码形式（UTF-8，UTF-16或UTF-32），每个字符将以一到四个8位字节，一个或两个16位代码单元的序列表示，或单个32位代码单元。

问：Unicode文本可以用多种方式表示吗？

答：是的，Unicode数据有几种可能的表示形式，包括UTF-8，UTF-16和UTF-32。此外，还有一些压缩转换，例如UTS＃6：Unicode标准压缩方案（SCSU）中描述的压缩转换 。

问：什么是UTF？

答：Unicode转换格式（UTF）是从每个Unicode代码点（代理代码点除外）到唯一字节序列的算法映射。ISO / IEC 10646标准对UTF使用术语“ UCS转换格式”。这两个术语只是同一概念的同义词。

每个UTF都是可逆的，因此每个UTF支持无损往返：从任何Unicode编码的字符序列S到字节序列的映射，然后再返回将生成S。为了确保往返，UTF映射 必须将所有代码点（代理代码点除外）映射到唯一的字节序列。这包括保留的（未分配的）代码点和66个非字符 （包括U + FFFE和U + FFFF）。

该SCSU 压缩方法，即使它是可逆的，不是UTF因为相同的字符串可以映射到非常多的不同的字节序列，这取决于特定的SCSU压缩机。[AF]

问：在哪里可以获得有关编码表单的更多信息？

答：有关UTF的正式定义，请参见 Unicode标准中的3.9节Unicode编码形式。有关编码形式的更多信息，请参见UTR＃17：Unicode字符编码模型。 [AF]

问：如何编写UTF转换器？

答：免费提供的开源项目Unicode国际组件（ICU）内置了UTF转换。可以从ICU Project网站下载最新版本。[AF]

问：是否有UTF不会生成的字节序列？我应该如何解释它们？

答：没有一个UTF可以生成每个任意字节序列。例如，在UTF-8的形式110xxxxx的每个字节2 必须遵循与窗体10xxxxxx的字节2。诸如<110xxxxx 2 0xxxxxxx 2 >之类的序列是非法的，并且绝对不能生成。当在转换或解释时遇到此非法字节序列时，符合UTF-8的进程必须对待第一个字节110xxxxx 2作为非法终止错误：例如，发信号通知错误，过滤出字节或使用诸如FFFD（REPLACEMENT CHARACTER）之类的标记表示字节。在后两种情况下，它将在第二个字节0xxxxxxx 2处继续处理。

合格进程不得将非法或格式错误的字节序列解释为字符，但是，它可能会采取错误恢复措施。没有一致的过程可以使用不规则字节序列来编码带外信息。

问：我需要支持哪些UTF？

答：UTF-8在网络上最常见。Java和Windows使用UTF-16。Linux和各种Unix系统都使用UTF-8和UTF-32。它们之间的转换都是基于算法的，快速且无损的。这使得在使用特定的UTF进行内部存储或处理时，很容易支持多种格式的数据输入或输出。  [AF]

问：UTF之间有什么区别？

答：下表总结了每个UTF的一些属性。 

名称	UTF-8	UTF-16	UTF-16BE	UTF-16LE	UTF-32	UTF-32BE	UTF-32LE
最小代码点	0000	0000	0000	0000	0000	0000	0000
最大码点	10FFFF	10FFFF	10FFFF	10FFFF	10FFFF	10FFFF	10FFFF
代码单位大小	8位	16位	16位	16位	32位	32位	32位
字节顺序	不适用	<物料清单>	大端	小端	<物料清单>	大端	小端
每个字符最少字节	1个	2	2	2	4	4	4
每个字符最多字节	4	4	4	4	4	4	4
表中的<BOM>表示字节顺序由字节顺序标记确定（如果出现在数据流的开头，则为big-endian）。 [AF]

问：为什么某些UTF的标签上带有BE或LE，例如UTF-16LE？

答：UTF-16和UTF-32使用分别为两个和四个字节长的代码单元。对于这些UTF，存在三个子类型：BE，LE和未标记。BE格式使用big-endian字节序列化（最高有效字节在前），LE格式使用little-endian字节序列化（最低有效字节在前），无标记格式默认情况下使用big-endian字节序列化，但可以包含字节顺序开头的标记表示实际使用的字节序列化。[AF]

问：是否有打包Unicode字符的标准方法，使其适合8位ASCII流？

答：有三个或四个选项可以使Unicode适合8位格式。

a）使用UTF-8。这将保留ASCII，而不保留Latin-1，因为字符> 127与Latin-1不同。UTF-8仅将ASCII中的字节用于ASCII字符。因此，它在ASCII字符作为语法字符（例如，文件名语法，标记语言等）具有重要性的任何环境中，但所有其他字符都可以使用任意字节的环境中也能很好地工作。
示例：“带急性的拉丁小写字母”（015B）将被编码为两个字节：C5 9B。

b）使用Java或C样式转义符，格式为\ uXXXXX或\ xXXXXX。该格式不是文本文件的标准格式，但在所讨论语言的框架中定义得很好，主要用于源文件。
示例：波兰语单词“wyjście”的中间是字符“ Latin Small Letter s with Acute”（015B）（该字符是一个字符），看起来像：“ wyj \ u015Bcie”。

c）使用HTML或XML中的&#xXXXX;或&#DDDDD;数字字符转义符。同样，这些不是纯文本文件的标准，但在这些标记语言的框架内定义良好。
示例：“wyjście”看起来像“ wyj&#x015B;cie”

d）使用SCSU。这种格式将Unicode压缩为8位格式，保留了大多数ASCII，但使用某些控制代码作为解码器的命令。但是，虽然ASCII文本在用SCSU编码后看起来像ASCII文本，但是其他字符有时也可能使用相同的字节值编码，这使得SCSU不适合盲目地将任何字节解释为ASCII字符的8位通道。
示例：“ <SC2>wyjÛcie”，其中<SC2>指示字节0x12，“Û”对应于字节0xDB。[AF]

问：以下哪种方法最好？

答：这取决于具体情况：在这四种方法中，d）使用最少的空间，但不能在大多数8位环境中透明使用。a）在纯文本文件中得到最广泛的支持，并且b）和c）使用最多的空间，但是在Java和C或分别在HTML和XML文件中，对于程序源文件得到了广泛的支持。  [AF]

问：哪种格式最标准？

答：这四个要求接收者都可以理解该格式，但是a）被认为是三种等效的Unicode编码形式之一，因此是标准的。在其给定的上下文之外使用b）或c）绝对被认为是非标准的，但是对于内部数据传输来说可能是一个很好的解决方案。使用SCSU本身是一个标准（用于压缩数据流），但是很少有通用接收器支持SCSU，因此它再次在内部数据传输中最有用。[AF]

UTF-8常见问题
问：UTF-8的定义是什么？

答：UTF-8是Unicode的面向字节的编码形式。有关其定义的详细信息，请参见《Unicode标准》中的第2.5节“编码形式”和第3.9节“ Unicode编码形式” 。具体请参见表3-6 UTF-8位分布 和表3-7格式正确的UTF-8字节序列，它们给出了编码形式的简要摘要。确保您参考的是Unicode标准的最新版本，因为 Unicode技术委员会随着时间的流逝收紧了UTF-8的定义，以更严格地实施唯一序列并禁止对某些无效字符进行编码。有互联网 关于UTF-8的RFC 3629。UTF-8在ISO / IEC 10646的附录D中也有定义。另请参见上面的问题，如何编写UTF转换器？

问：无论底层处理器是小端还是大端，UTF-8编码方案都是一样的吗？

答：是的。由于UTF-8被解释为字节序列，因此不存在字节序问题，就像使用16位或32位代码单元的编码形式一样。当BOM与UTF-8一起使用时，它 仅用作将UTF-8与其他编码区分开的编码签名-与字节顺序无关。  [AF]

问：无论底层系统使用ASCII编码还是EBCDIC编码，UTF-8编码方案都相同吗？

答：关于UTF-8，只有一个定义。无论数据是从基于ASCII的字符集还是基于EBCDIC的字符集转换而成的，都完全一样。但是，由于ASCII和EBCDIC之间控制代码的安排不同，因此标准UTF-8的字节序列在EBCDIC系统中无法很好地互操作。 UTR＃16：UTF-EBCDIC定义了一种专用的UTF，它将在EBCDIC系统中进行互操作。 [AF]

问：如何将诸如<D800 DC00>之类的UTF-16代理对转换为UTF-8？作为一个4字节序列还是两个单独的3字节序列？

答：UTF-8的定义要求使用单个4字节序列对补充字符（在UTF-16中使用代理对的字符）进行编码。但是，在较旧的软件中，尤其是在引入UTF-16之前或在特定限制下与UTF-16环境进行互操作的软件，通常会生成3字节序列对。这样的编码不符合 所定义的UTF-8。有关此类非UTF-8数据格式的正式说明，请参见UTR＃26：UTF-16的兼容性编码方案：8位（CESU）。使用CESU-8时，由于格式的相似性，必须格外小心，不要意外地将数据视为UTF-8。 [AF]

问：如何将未配对的UTF-16代理转换为UTF-8？

如果在转换格式不正确的UTF-16数据时遇到未配对的代理，则会出现另一个问题。通过将这样一个未配对的代理单独表示为3字节序列，所得的UTF-8数据流将变得格式错误。尽管它忠实地反映了输入的性质，但Unicode一致性要求编码格式转换始终产生有效的数据流。因此，转换器必须将此视为错误。[AF]

UTF-16常见问题
问：什么是UTF-16？

答：UTF-16使用单个16位代码单元对最常见的63K字符进行编码，并使用一对16位代码单元（称为替代）对Unicode中不常用的1M字符进行编码。

最初，Unicode被设计为纯16位编码，旨在表示所有现代脚本。（古代的脚本用专用字符表示。）随着时间的流逝，尤其是在添加了超过14,500个复合字符以与传统集兼容的情况下，很明显16位对于用户社区是不够的。由此产生了UTF-16。 [AF]

问：什么是代理人？

答：替代是来自Unicode值的两个特殊范围的代码点，保留作为UTF-16中成对代码单元的前导值和尾随值。前代理（也称为高代理）是从D800 16到DBFF 16，而尾部或低代理是从DC00 16到DFFF 16。它们被称为代理人，因为它们不直接代表字符，而只是成对出现。

问：从UTF-16转换为字符代码的算法是什么？

答：Unicode标准曾经包含一个简短的算法，现在只有一个位分配表。这是三个简短的代码段，这些代码段将位分配表中的信息转换为C代码，这些代码将与UTF-16相互转换。

使用以下类型定义

typedef unsigned int16 UTF16;
typedef unsigned int32 UTF32;
第一个代码段根据字符代码C计算高（或前导）替代词。

const UTF16 HI_SURROGATE_START = 0xD800
UTF16 X =（UTF16）C;
UTF32 U =（C >> 16）＆（（1 << 5）-1）;
UTF16 W =（UTF16）U-1;
UTF16 HiSurrogate = HI_SURROGATE_START | （W << 6）| X >> 10;
其中X，U和W对应于表3-5 UTF-16位分布中使用的标签。下一个代码段对低代理人也是如此。

const UTF16 LO_SURROGATE_START = 0xDC00
UTF16 X =（UTF16）C;
UTF16 LoSurrogate =（UTF16）（LO_SURROGATE_START | X＆（（1 << 10）-1））;
最后，反之，其中hi和lo是高和低代理，C是结果字符

UTF32 X =（hi＆（（1 << 6）-1））<< 10 | lo＆（（1 << 10）-1）;
UTF32 W =（hi >> 6）＆（（1 << 5）-1）;
UTF32 U = W +1;
UTF32 C = U << 16 | X;
调用者将需要确保C，hi和lo在适当的范围内。[AF]

问：难道没有更简单的方法吗？

答：有一种更简单的计算方法，它不会尝试遵循位分配表。

//常数
const UTF32 LEAD_OFFSET = 0xD800-（0x10000 >> 10）;
const UTF32 SURROGATE_OFFSET = 0x10000-（0xD800 << 10）-0xDC00;

//计算
UTF16引线= LEAD_OFFSET +（代码点>> 10）;
UTF16追踪= 0xDC00 +（代码点和0x3FF）;

UTF32代码点=（前导<< 10）+轨迹+ SURROGATE_OFFSET;
[MD]

问：为什么有些人反对UTF-16？

答：熟悉Shift-JIS（SJIS）等东亚可变宽度字符集的人对UTF-16感到不安，这有时需要两个代码单元来表示一个字符。他们非常熟悉可变宽度代码所引起的问题。但是，SJIS和UTF-16中使用的机制之间存在一些重要区别：

交叠：

在SJIS中，前导码和尾码单元值之间以及尾码和单个码单元值之间存在重叠。这会导致许多问题：

它会导致错误的匹配。例如，搜索“ a”可能与日语字符的尾码单元匹配。

它阻止有效的随机访问。要知道您是否处于字符边界上，必须向后搜索以找到已知边界。

它使文本非常脆弱。如果一个单元从前导代码单元对中删除，则许多后面的字符可能会损坏。

在UTF-16中，高和低替代项以及单个单元的代码点范围完全不相交。这些问题均不会发生：

没有错误的匹配。

字符边界的位置可以直接从每个代码单位值中确定。

放弃的代理将仅破坏单个字符。

频率：

绝大多数SJIS字符需要2个单位，但是使用单个单位的字符很常见，并且通常具有特殊重要性，例如在文件名中。

使用UTF-16，相对较少的字符需要2个单位。常用的绝大多数字符是单个代码单元。即使在东亚文本中，代理对的发生率也应该平均不到所有文本存储的1％。（当然，某些文件可能会出现更多的替代对，就像phthisique在英语中是一个相当少见的词，但在特定的学术著作中却经常会出现。） [AF]

问：UTF-16是否会扩展到超过一百万个字符？

答：不能。Unicode和ISO 10646都有适当的策略，可以将将来的代码分配形式正式限制为可以使用当前UTF-16（0到1,114,111）表示的整数范围。即使其他编码形式（即其他UTF）可以表示较大的整数，这些策略也意味着所有编码形式将始终表示同一组字符。对于编码字符而不是字形的Unicode目标，超过一百万种可能的代码远远不够。Unicode不是设计用于编码任意数据。例如，如果您想要为每个“整个历史上的纸上人物实例”赋予其自己的代码，则可能需要数万亿或上万亿的此类代码。尽力而为，您不会使用Unicode进行这种编码。 [AF]

问：是否有任何无效的16位值？

答：未配对的替代品在UTF中无效。这些值包括D800 16到DBFF 16范围内的任何值，后跟DC00 16 到DFFF 16范围内的值，或DC00 16到DFFF 16范围内的任何值前，没有D800 16到DBFF 16范围内的值。[AF]

问：非字符呢？他们无效吗？

答：完全没有。非字符在UTF中有效，必须正确转换。有关非字符的定义和使用以及它们在每个UTF中的正确表示的更多详细信息，请参阅“非字符常见问题解答”。

问：因为大多数辅助字符都不常见，这是否意味着我可以忽略它们？

答：大多数补充字符（用UTF-16中的代理对表示）不太常见。然而，这并不能意味着增补字符应该被忽略。其中有许多非常受欢迎的单个字符，以及许多对东亚采购规格很重要的字符。其中值得注意的补充字符包括：

许多流行的表情符号和表情符号

用于与Wingdings和Webdings互操作的符号

许多对采购很重要的CJK小字符，包括个人名称和地名

用于所有表意变化序列的变化选择器

对某些用户社区很重要的众多少数群体脚本

一些高度突出的历史文字，例如埃及象形文字

肯·伦德（Ken Lunde）对此主题有一个有趣的演示文件，其中包含十大列表：为什么支持Beyond-BMP代码点？

问：我应该如何处理代码中的补充字符？

答：与整个BMP字符相比，补充字符在文本中较少出现。即使在标准中添加了成千上万个辅助字符，并且一些单独的字符（例如流行的表情符号）也变得相当普遍，现在仍然如此。优化实现最佳性能的实现时，可以考虑BMP字符和BMP内ASCII子集的相对频率：执行速度，内存使用率和数据存储。

这样的策略对于UTF-16实现特别有用，在这种实现中，BMP字符需要一个16位代码单元来处理或存储，而补充字符需要两个。

针对BMP进行优化的策略对UTF-8实现的用处不大，但是，如果数据分配可以保证的话，对ASCII子集进行优化可能就有意义了，因为该子集只需要一个字节即可在UTF-8中进行处理和存储。 。

问：UCS-2和UTF-16有什么区别？

答：UCS-2是过时的术语，指的是直至Unicode 1.1为止的Unicode实现，然后才将替代代码点和UTF-16添加到标准的2.0版中。现在应避免使用该术语。

UCS-2没有描述不同于UTF-16的数据格式，因为两者都使用完全相同的16位代码单元表示形式。但是，UCS-2不会解释代理代码点，因此不能用于一致地表示补充字符。

过去，有时某个实现被标记为“ UCS-2”，以表示它不支持补充字符，并且不将代理代码点对解释为字符。这样的实现将不处理辅助字符的字符属性，代码点边界，归类等处理。[AF]

UTF-32常见问题
问：什么是UTF-32？

答：在UTF-32中，任何Unicode字符都可以表示为单个32位单元。这个单一的4码单位对应于Unicode标量值，它是与Unicode字符关联的抽象数字。UTF-32是ISO 10646中称为UCS-4的编码机制的子集。有关更多信息，请参见Unicode标准中的3.9节Unicode编码形式。[AF] 

问：我应该使用UTF-32（或UCS-4）在内存中存储Unicode字符串吗？

答：这取决于。如果您经常需要访问要求字符串参数使用UTF-32的API，那么始终使用UTF-32字符串可能会更方便。但是，UTF-32的缺点是，当您只需要21位时，它会强制您为每个字符使用32位。普通文本中的平均字符所需的有效位数量要少得多，这实际上使比率变得更糟。在许多情况下都没有关系，每个字符具有固定数量的代码单元的便利性可能是决定因素。

在处理大量文本数据的应用程序中，增加相同数量字符的存储量确实会带来成本：这可能意味着尽快耗尽缓存限制；它可能会导致明显增加的读/写时间或达到带宽限制；并且需要更多的存储空间。许多实现方式是使用UTF-16表示字符串，但使用UTF-32表示单个字符值。

Unicode的主要卖点是提供世界上所有字符的表示，从而消除了处理多个字符集的需要，并避免了相关的数据损坏问题。这些功能足以使行业转向使用Unicode（UTF-16）。虽然UTF-32表示确实使编程模型更简单，但是增加的平均存储大小却有实际缺点，这使得向UTF-32的完整过渡不太引人注目。 [AF]

问：如何在我的API中使用UTF-32接口？

答：除了在某些将文本以UTF-32形式存储在内存中的环境外，大多数Unicode API都使用UTF-16。使用UTF-16 API，低级索引位于存储或代码单元级别，而针对字素或单词的高级机制则根据代码单元指定其边界。这在低级别提供了效率，而在高级别提供了所需的功能。

如果有必要找到第n个 字符，则可以将按字符进行索引作为高级操作来实现。但是，虽然从这样的UTF-16代码单元索引转换为字符索引（反之亦然）很简单，但它确实涉及到16位单元的扫描，直到索引点。例如，在测试运行中，以字符而不是代码单位访问UTF-16存储导致10倍的降级。尽管可以执行一些有趣的优化，但平均而言，它总是较慢。因此，定位其他边界（例如字素，单词，行或句子的边界）直接从代码单元索引开始，而不是间接通过中间字符代码索引来进行。

问：只有UTF-16字符串API而不是UTF-32 char API会不会引起问题？

答：几乎所有国际功能（上，下，标题框，折叠，绘图，测量，整理，音译，字素，字词，换行符等）都应该在API中使用 字符串参数，而不是单个代码点（UTF-32）。除了非常简单的语言外，单个代码点API几乎总是产生错误的结果，要么是因为您需要更多的上下文来获得正确的答案，要么是因为您需要生成一个字符序列以返回正确的答案，或者两者兼而有之。

例如，任何符合Unicode的归类（请参阅UTS＃10：Unicode归类算法（UCA））必须能够处理多个代码点的序列，并将该序列视为单个实体。尝试通过一次处理单个代码点进行整理，将得到错误的答案。一次在单个代码点上绘制或测量文本也会发生同样的情况；因为像阿拉伯语这样的脚本是上下文相关的，所以x的宽度加上y的宽度不等于xy的宽度 。一旦您超越了基本的排版，英语也是如此。由于字距调整和连字，字体中“ fi”的宽度可能不同于“ f”的宽度加上“ i”的宽度。框操作必须返回字符串，而不是单个代码点；请参见 http：// www .unicode.org / charts / case /。特别是，标题框操作需要使用字符串作为输入，而不是一次输入单个代码点。

在结构或类中而不是字符串中存储单个代码点将排除对字素的支持，例如斯洛伐克语的“ ch”，其中单个代码点可能不够，但是需要一个字符序列来表达所需的内容。换句话说，大多数API参数和复合数据类型的字段都不应定义为字符，而应 定义为字符串。如果它们是字符串，则字符串的内部表示形式无关紧要。

鉴于任何具有行业实力的文本和国际化支持API都必须能够处理字符序列，因此无论字符串是内部由UTF-16代码单元序列还是由代码点序列（ = UTF-32代码单位）。由于给定代码点的代码单元序列是唯一的，因此UTF-16和UTF-8的设计都使使用子字符串变得容易。[AF]

问：在API中仅使用字符串参数的规则是否有例外？

答：主要例外是非常低级的操作，例如获取字符属性（例如，UCD中的常规类别或规范类）。对于那些接口，具有在UTF-16和UTF-32之间快速转换的接口非常方便，并且允许您迭代返回UTF-32值的字符串（即使内部格式为UTF-16）。

问：如何将诸如<D800 DC00>之类的UTF-16代理对转换为UTF-32？是一个4字节序列还是两个4字节序列？

答：UTF-32的定义要求补充字符（使用UTF-16中的代理对的补充字符）必须使用单个4字节序列编码。

问：如何将未配对的UTF-16代理转换为UTF-32？

答：如果在转换格式不正确的UTF-16数据时遇到未配对的代理，则任何合格的转换器都必须 将此视为错误。通过单独表示这样的未配对代理，所得的UTF-32数据流将变得格式错误。Unicode一致性虽然忠实地反映了输入的性质，但要求编码形式转换始终产生有效的数据流。[AF]

字节顺序标记（BOM）常见问题解答
问：什么是BOM？

答：字节顺序标记（BOM）由数据流开头的字符代码U + FEFF组成，在这里它可用作定义字节顺序和编码形式的签名，主要是未标记的纯文本文件。在某些更高级别的协议下，在该协议中定义的Unicode数据流中，可能必须（或禁止）使用BOM。 [AF]

问：BOM在哪里有用？

答：BOM表在键入为文本的文件的开头很有用，但尚不清楚它们是大字节序还是小字节序格式的-它也可以用作提示，指示文件采用Unicode，例如与传统编码相反，并且它充当所使用的特定编码形式的签名。[AF]

问：“字节序”是什么意思？

答：长度大于一个字节的数据类型可以存储在计算机内存中，最高有效字节（MSB）在前或最后。前者称为大尾数法，后者称为小尾数法。交换数据时，在发送系统上以“正确”顺序出现的字节在接收系统上可能看起来是乱序的。在那种情况下，BOM看起来像0xFFFE，这是一个非字符，允许接收系统在处理数据之前应用字节反转。UTF-8是面向字节的，因此没有该问题。不过，初始BOM可能对将数据流标识为UTF-8有用。[AF]

问：使用BOM时，是否仅使用16位Unicode文本？

答：不可以，无论Unicode文本如何转换，BOM都可以用作签名：UTF-16，UTF-8或UTF-32。构成BOM的确切字节将是该转换格式将Unicode字符U + FEFF转换为的字节。BOM以这种形式指示它是一个Unicode文件，以及它所采用的格式。示例：

字节数	编码形式
00 00 FE FF	UTF-32，大端
FF FE 00 00	UTF-32，小端
有限元	UTF-16，大端
FF FE	UTF-16，小端
EF BB高炉	UTF-8
问：UTF-8数据流是否可以包含BOM字符（采用UTF-8格式）？如果是，那么我是否仍可以假定其余的UTF-8字节按大端顺序排列？

答：是的，UTF-8可以包含BOM。但是， 字节流的字节顺序没有区别。UTF-8始终具有相同的字节顺序。初始BOM仅用作签名-表示未标记的文本文件位于UTF-8中。请注意，某些UTF-8编码数据的收件人不希望使用BOM。在8位环境中透明地使用UTF-8的情况下，BOM的使用会干扰任何期望开头使用特定ASCII字符的协议或文件格式，例如“＃！”的使用。Unix Shell脚本开头的内容。 [AF]

问：我应该在文件中间使用U + FEFF？

答：在没有支持将其用作BOM的协议的情况下，并且不在文本流的开头时，通常不应出现U + FEFF。为了向后兼容，应将其视为零宽度无中断空间（ZWNBSP），然后将其作为文件或字符串内容的一部分。与ZWNBSP相比，使用U + 2060 WORD JOINER来表达单词连接语义是更可取的，因为它不能与BOM混淆。在设计标记语言或数据协议时，可以将U + FEFF的使用限制为字节顺序标记。在这种情况下，任何出现在文件中间的U + FEFF都可以视为 不支持的字符。 [AF]

问：我使用的协议的文本开头是BOM。我如何代表初始ZWNBSP？

答：请改用U + 2060 WORD JOINER。 

问：如何标记不将U + FEFF解释为BOM的数据？

答：使用标记UTF-16BE表示大尾数UTF-16文本，使用标签UTF- 16LE表示小尾数UTF-16文本。如果确实使用BOM，则将文本标记为简单的UTF-16。 [MD]

问：为什么我不总是使用需要BOM的协议？

答：如果数据具有关联的类型（例如数据库中的字段），则不需要BOM。特别是，如果文本数据流被标记为UTF-16BE，UTF-16LE，UTF-32BE或UTF-32LE，则BOM既不是必需的，也不是允许的。任何U + FEFF都将被解释为ZWNBSP。

不要用BOM表标记数据库或字段集中的每个字符串，因为这会浪费空间并使字符串连接复杂化。而且，这还意味着两个数据字段可能具有完全相同的内容，但不是二进制相等的（其中一个以BOM表开头）。

问：我应该如何处理BOM？

答：以下是一些指导原则：

特定协议（例如，Microsoft .txt文件约定）可能要求在某些Unicode数据流（例如文件）上使用BOM。当您需要遵循此类协议时，请使用BOM。

对于未加标签的文本，某些协议允许使用可选的BOM。在那种情况下

如果已知文本数据流是纯文本，但是编码方式未知，则BOM可用作签名。如果没有BOM，则编码可以是任何形式。

如果已知文本数据流是纯Unicode文本（而不是哪个字节序），则BOM可以用作签名。如果没有BOM，则文本应解释为big-endian。

某些面向字节的协议期望在文件开头使用ASCII字符。如果这些协议使用UTF-8，则应避免使用BOM作为编码形式签名。

在已知数据流的确切类型的地方（例如Unicode大端或Unicode小端），不应使用BOM。特别地，每当一个:数据流被声明为UTF-16BE，UTF-16LE，UTF-32BE或UTF-32LE一个BOM必须不能使用。（另请参阅问：UCS-2和UTF-16有什么区别？。） [AF]
